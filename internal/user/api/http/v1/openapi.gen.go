// Package v1 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.16.2 DO NOT EDIT.
package v1

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/gin-gonic/gin"
	"github.com/oapi-codegen/runtime"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// 修改用户信息
	// (PUT /api/v1/user)
	UpdateUser(c *gin.Context)
	// 用户激活
	// (GET /api/v1/user/activate)
	UserActivate(c *gin.Context, params UserActivateParams)
	// 修改用户头像
	// (PUT /api/v1/user/avatar)
	UpdateUserAvatar(c *gin.Context)
	// 修改用户密钥包
	// (PUT /api/v1/user/bundle)
	UpdateUserBundle(c *gin.Context)
	// 获取该用户当前登录的所有客户端
	// (GET /api/v1/user/clients)
	GetUserLoginClients(c *gin.Context)
	// 发送激活邮件
	// (POST /api/v1/user/email/verification)
	UserEmailVerification(c *gin.Context)
	// 用户登录
	// (POST /api/v1/user/login)
	UserLogin(c *gin.Context)
	// 退出登录
	// (POST /api/v1/user/logout)
	UserLogout(c *gin.Context)
	// 修改密码
	// (PUT /api/v1/user/password)
	UpdateUserPassword(c *gin.Context)
	// 设置用户pgp公钥
	// (POST /api/v1/user/public_key)
	SetUserPublicKey(c *gin.Context)
	// 重置用户公钥
	// (PUT /api/v1/user/public_key)
	ResetUserPublicKey(c *gin.Context)
	// 用户注册
	// (POST /api/v1/user/register)
	UserRegister(c *gin.Context)
	// 搜索用户
	// (GET /api/v1/user/search)
	SearchUser(c *gin.Context, params SearchUserParams)
	// 确认登录
	// (POST /api/v1/user/sso/confirm_login/{token})
	ConfirmLogin(c *gin.Context, token string)
	// 生成二维码
	// (GET /api/v1/user/sso/generate_qr)
	GenerateQRCode(c *gin.Context)
	// 完成登录
	// (POST /api/v1/user/sso/login/{token})
	SsoLogin(c *gin.Context, token string)
	// 验证二维码状态
	// (GET /api/v1/user/sso/qr_status/{token})
	VerifyQRCodeStatus(c *gin.Context, token string)
	// 扫描二维码
	// (POST /api/v1/user/sso/scan_qr)
	ScanQRCode(c *gin.Context)
	// 获取服务端pgp公钥
	// (GET /api/v1/user/system/public_key)
	GetPGPPublicKey(c *gin.Context)
	// 获取用户信息
	// (GET /api/v1/user/{id})
	GetUser(c *gin.Context, id string)
	// 获取用户密钥包
	// (GET /api/v1/user/{id}/bundle)
	GetUserBundle(c *gin.Context, id string)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandler       func(*gin.Context, error, int)
}

type MiddlewareFunc func(c *gin.Context)

// UpdateUser operation middleware
func (siw *ServerInterfaceWrapper) UpdateUser(c *gin.Context) {

	c.Set(BearerAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.UpdateUser(c)
}

// UserActivate operation middleware
func (siw *ServerInterfaceWrapper) UserActivate(c *gin.Context) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params UserActivateParams

	// ------------- Required query parameter "user_id" -------------

	if paramValue := c.Query("user_id"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument user_id is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "user_id", c.Request.URL.Query(), &params.UserId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter user_id: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Required query parameter "key" -------------

	if paramValue := c.Query("key"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument key is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "key", c.Request.URL.Query(), &params.Key)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter key: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.UserActivate(c, params)
}

// UpdateUserAvatar operation middleware
func (siw *ServerInterfaceWrapper) UpdateUserAvatar(c *gin.Context) {

	c.Set(BearerAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.UpdateUserAvatar(c)
}

// UpdateUserBundle operation middleware
func (siw *ServerInterfaceWrapper) UpdateUserBundle(c *gin.Context) {

	c.Set(BearerAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.UpdateUserBundle(c)
}

// GetUserLoginClients operation middleware
func (siw *ServerInterfaceWrapper) GetUserLoginClients(c *gin.Context) {

	c.Set(BearerAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetUserLoginClients(c)
}

// UserEmailVerification operation middleware
func (siw *ServerInterfaceWrapper) UserEmailVerification(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.UserEmailVerification(c)
}

// UserLogin operation middleware
func (siw *ServerInterfaceWrapper) UserLogin(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.UserLogin(c)
}

// UserLogout operation middleware
func (siw *ServerInterfaceWrapper) UserLogout(c *gin.Context) {

	c.Set(BearerAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.UserLogout(c)
}

// UpdateUserPassword operation middleware
func (siw *ServerInterfaceWrapper) UpdateUserPassword(c *gin.Context) {

	c.Set(BearerAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.UpdateUserPassword(c)
}

// SetUserPublicKey operation middleware
func (siw *ServerInterfaceWrapper) SetUserPublicKey(c *gin.Context) {

	c.Set(BearerAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.SetUserPublicKey(c)
}

// ResetUserPublicKey operation middleware
func (siw *ServerInterfaceWrapper) ResetUserPublicKey(c *gin.Context) {

	c.Set(BearerAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ResetUserPublicKey(c)
}

// UserRegister operation middleware
func (siw *ServerInterfaceWrapper) UserRegister(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.UserRegister(c)
}

// SearchUser operation middleware
func (siw *ServerInterfaceWrapper) SearchUser(c *gin.Context) {

	var err error

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchUserParams

	// ------------- Required query parameter "email" -------------

	if paramValue := c.Query("email"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument email is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "email", c.Request.URL.Query(), &params.Email)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter email: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.SearchUser(c, params)
}

// ConfirmLogin operation middleware
func (siw *ServerInterfaceWrapper) ConfirmLogin(c *gin.Context) {

	var err error

	// ------------- Path parameter "token" -------------
	var token string

	err = runtime.BindStyledParameter("simple", false, "token", c.Param("token"), &token)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter token: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ConfirmLogin(c, token)
}

// GenerateQRCode operation middleware
func (siw *ServerInterfaceWrapper) GenerateQRCode(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GenerateQRCode(c)
}

// SsoLogin operation middleware
func (siw *ServerInterfaceWrapper) SsoLogin(c *gin.Context) {

	var err error

	// ------------- Path parameter "token" -------------
	var token string

	err = runtime.BindStyledParameter("simple", false, "token", c.Param("token"), &token)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter token: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.SsoLogin(c, token)
}

// VerifyQRCodeStatus operation middleware
func (siw *ServerInterfaceWrapper) VerifyQRCodeStatus(c *gin.Context) {

	var err error

	// ------------- Path parameter "token" -------------
	var token string

	err = runtime.BindStyledParameter("simple", false, "token", c.Param("token"), &token)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter token: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.VerifyQRCodeStatus(c, token)
}

// ScanQRCode operation middleware
func (siw *ServerInterfaceWrapper) ScanQRCode(c *gin.Context) {

	c.Set(BearerAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ScanQRCode(c)
}

// GetPGPPublicKey operation middleware
func (siw *ServerInterfaceWrapper) GetPGPPublicKey(c *gin.Context) {

	c.Set(BearerAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetPGPPublicKey(c)
}

// GetUser operation middleware
func (siw *ServerInterfaceWrapper) GetUser(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", c.Param("id"), &id)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetUser(c, id)
}

// GetUserBundle operation middleware
func (siw *ServerInterfaceWrapper) GetUserBundle(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", c.Param("id"), &id)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetUserBundle(c, id)
}

// GinServerOptions provides options for the Gin server.
type GinServerOptions struct {
	BaseURL      string
	Middlewares  []MiddlewareFunc
	ErrorHandler func(*gin.Context, error, int)
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router gin.IRouter, si ServerInterface) {
	RegisterHandlersWithOptions(router, si, GinServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router gin.IRouter, si ServerInterface, options GinServerOptions) {
	errorHandler := options.ErrorHandler
	if errorHandler == nil {
		errorHandler = func(c *gin.Context, err error, statusCode int) {
			c.JSON(statusCode, gin.H{"msg": err.Error()})
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandler:       errorHandler,
	}

	router.PUT(options.BaseURL+"/api/v1/user", wrapper.UpdateUser)
	router.GET(options.BaseURL+"/api/v1/user/activate", wrapper.UserActivate)
	router.PUT(options.BaseURL+"/api/v1/user/avatar", wrapper.UpdateUserAvatar)
	router.PUT(options.BaseURL+"/api/v1/user/bundle", wrapper.UpdateUserBundle)
	router.GET(options.BaseURL+"/api/v1/user/clients", wrapper.GetUserLoginClients)
	router.POST(options.BaseURL+"/api/v1/user/email/verification", wrapper.UserEmailVerification)
	router.POST(options.BaseURL+"/api/v1/user/login", wrapper.UserLogin)
	router.POST(options.BaseURL+"/api/v1/user/logout", wrapper.UserLogout)
	router.PUT(options.BaseURL+"/api/v1/user/password", wrapper.UpdateUserPassword)
	router.POST(options.BaseURL+"/api/v1/user/public_key", wrapper.SetUserPublicKey)
	router.PUT(options.BaseURL+"/api/v1/user/public_key", wrapper.ResetUserPublicKey)
	router.POST(options.BaseURL+"/api/v1/user/register", wrapper.UserRegister)
	router.GET(options.BaseURL+"/api/v1/user/search", wrapper.SearchUser)
	router.POST(options.BaseURL+"/api/v1/user/sso/confirm_login/:token", wrapper.ConfirmLogin)
	router.GET(options.BaseURL+"/api/v1/user/sso/generate_qr", wrapper.GenerateQRCode)
	router.POST(options.BaseURL+"/api/v1/user/sso/login/:token", wrapper.SsoLogin)
	router.GET(options.BaseURL+"/api/v1/user/sso/qr_status/:token", wrapper.VerifyQRCodeStatus)
	router.POST(options.BaseURL+"/api/v1/user/sso/scan_qr", wrapper.ScanQRCode)
	router.GET(options.BaseURL+"/api/v1/user/system/public_key", wrapper.GetPGPPublicKey)
	router.GET(options.BaseURL+"/api/v1/user/:id", wrapper.GetUser)
	router.GET(options.BaseURL+"/api/v1/user/:id/bundle", wrapper.GetUserBundle)
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"HuF+QaZTLucEJpgZnflvAAAA///88K/QoD8AAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
